<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <link rel="stylesheet" href="stylesheet.css">
    <style>
        html, body {
            width:  100%;
            height: 100%;
            margin: 0;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="500" height="500"></canvas>

    <script>
        let canvas = document.querySelector("#canvas");
        let ctx = canvas.getContext("2d");
        ctx.canvas.width  = window.innerWidth;
        ctx.canvas.height = window.innerHeight;

        // Defaults
        const height = 3;
        const strokeWidth = 3;
        const strokeColor = 'black';
        const boids = [];
        const speed = 3;


        let clicked = false;
        let sel = $('#canvas');

        sel.mousedown(function (mouseEvent) {
            addBoid(mouseEvent.pageX, mouseEvent.pageY, (Math.random() * 360), "yellow");
            clicked = true;
        });

        sel.mousemove(function(mouseEvent) {
            if(clicked) {
                addBoid(mouseEvent.pageX, mouseEvent.pageY, (Math.random() * 360), "black");
            }
        });

        sel.mouseup(function () { clicked = false; });

        let interval = setInterval(draw, 10);

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for(let i = 0; i < boids.length; i++) {
                findNewPosition(boids[i]);
                drawPolygon(boids[i].x, boids[i].y, 3, height, strokeWidth, strokeColor, boids[i].color, boids[i].dir);
            }
        }

        function findNewPosition(boid) {
            let radianDir = boid.dir * Math.PI/180;

            let dx = boid.x + speed * (Math.cos(radianDir));
            let dy = boid.y + speed * (Math.sin(radianDir));

            let closestBoids = getClosestBoids(boid);

            let avgDir = 0;
            let avgX = 0;
            let avgY = 0;
            for(let i = 0; i < closestBoids.length; i++) {
                avgDir += closestBoids[i].dir;
                avgX += closestBoids[i].x;
                avgY += closestBoids[i].y;
            }
            avgDir /= closestBoids.length;
            avgX /= closestBoids.length;
            avgY /= closestBoids.length;


            let valDir;
            let valX;
            let valY;
            if(boid.dir - avgDir < 0) {
                valDir = 1;
            } else {
                valDir = -1;
            }

            if(boid.x - avgX > 0) {
                valX = 1;
            } else {
                valX = -1;
            }

            if(boid.y - avgY < 0) {
                valY = 1;
            } else {
                valY = -1;
            }

            boid.setDir(boid.dir + (2 * valDir) + (2*valX) + (2*valY));

            if(boid.dir < 0) {
                boid.setDir(360 + boid.dir);
            } else if(boid.dir > 360) {
                boid.setDir(boid.dir - 360);
            }

            if(boid.x > ctx.canvas.width) { dx = 0 }
            else if(boid.x < 0) { dx = ctx.canvas.width }

            if(boid.y > ctx.canvas.height) { dy = 0 }
            else if(boid.y < 0) { dy = ctx.canvas.height }

            boid.setX(dx);
            boid.setY(dy);
        }

        function getClosestBoids(boid) {
            let closestBoidNums = [9999,9999,9999,9999,9999];
            let closestBoids = [boid,boid,boid,boid,boid]

            for(let i = 0; i < boids.length; i++) {
                if(boids[i] !== boid) {
                    for(let j = 0; j < 5; j++) {
                        let distance = dist(boid.x, boid.y, boids[i].x, boids[i].y);
                        if(!closestBoids.includes(boids[i]) && distance < closestBoidNums[j]) {
                            closestBoids[j] = boids[i];
                            closestBoidNums[j] = distance;
                        }
                    }

                    // Sort list in descending order
                    closestBoids.sort(function (a, b) {
                        return b - a
                    });
                }
            }

            return closestBoids;
        }

        function dist(x1,y1,x2,y2) {
            return (Math.sqrt(Math.pow(x1-x2,2) - Math.pow(y1-y2,2)));
        }

        function addBoid(x,y,dir,color) {
        	if(boids.length < 100) {
				boids.push(new Boid(x, y, dir, color));
            }
       	}

        function deleteBoid() {
            boids.pop();
        }

        // https://stackoverflow.com/questions/38238282/how-to-rotate-a-triangle-without-rotating-the-entire-canvas
        function drawPolygon(centerX,centerY,sideCount,size,strokeWidth,strokeColor,fillColor,degrees){
            let radians=(degrees - 90)*Math.PI/180;
            ctx.translate(centerX,centerY);
            ctx.rotate(radians);
            ctx.beginPath();
            ctx.moveTo (size * Math.cos(0), size * Math.sin(0));
            for (let i = 1; i <= sideCount;i += 1) {
                ctx.lineTo (size * Math.cos(i * 2 * Math.PI / sideCount), size * Math.sin(i * 2 * Math.PI / sideCount));
            }
            ctx.closePath();
            ctx.fillStyle=fillColor;
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = strokeWidth;
            ctx.stroke();
            ctx.fill();
            ctx.rotate(-radians);
            ctx.translate(-centerX,-centerY);
        }

        class Boid {
            constructor(x,y,dir,color) {
                this.x = x;
                this.y = y;
                this.dir = dir;
                this.color = color;
            }

            setX(x) {
                this.x = x;
            }

            setY(y) {
                this.y = y;
            }

            setDir(dir) {
                this.dir = dir;
            }
        }
    </script>
</body>
</html>